!function(){function e(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function t(){let t={},n=new Set,s={},r=e=>{if(!(e in s)){let t,n;s[e]={promise:new Promise((e,s)=>{t=e,n=s}),resolve:t,reject:n}}return s[e].promise},i={},o=e=>(r(e),i[e]=s[e],i[e].promise),d=e=>{if(e in t)return t[e];throw Error(`Attempted to get ${e} before it was available: is it missing entrypoint: true in its package.json?`)},a=e=>{e.instance={};let t=e=>o(e);t.meta={url:"",hot:{performReactRefresh:()=>{}}};let n=e.initialize((t,n)=>{"object"==typeof t||"function"==typeof t?Object.assign(e.instance,t):e.instance&&(e.instance[t]=n);for(let t=0;t<e.dependents.length;t++)e.dependents[t](e.instance);return n},t);e.execute=()=>{n[0](),r(e.id),s[e.id].resolve(e.instance)};let i=n[1];for(let t=0;t<e.dependencies.length;t++){let n=d(e.dependencies[t]);n.dependents.push(i[t]),n.instance&&i[t](n.instance)}},l=(e,t,n)=>{let s=n;if(1===e.status||2===e.status||4===e.status)return s;e.status=1,e.dfsIndex=s,e.dfsAncestorIndex=s,s++,t.push(e);for(let n=0;n<e.dependencies.length;n++){let r=d(e.dependencies[n]);s=l(r,t,s),1===r.status&&(e.dfsAncestorIndex=Math.min(e.dfsAncestorIndex,r.dfsAncestorIndex))}if(a(e),e.dfsAncestorIndex===e.dfsIndex)for(;;){let n=t.pop();if(n.status=2,n===e)break}return s},c=e=>{let t=[];try{l(e,t,0)}catch(e){throw t.forEach(e=>{e.status=0,e.dfsIndex=void 0,e.dfsAncestorIndex=void 0}),e}},u=(e,t,n)=>{let s=n;if(4===e.status){if(void 0===e.evaluationError)return s;throw e.evaluationError}if(3===e.status)return s;e.status=3,e.dfsIndex=s,e.dfsAncestorIndex=s,s++,t.push(e);for(let n=0;n<e.dependencies.length;n++){let r=d(e.dependencies[n]);s=u(r,t,s),3===r.status&&(e.dfsAncestorIndex=Math.min(r.dfsAncestorIndex,e.dfsAncestorIndex))}if(!e.execute)throw Error(void 0);if(e.execute(),e.dfsAncestorIndex===e.dfsIndex)for(;;){let n=t.pop();if(n.status=4,n===e)break}return s},f=e=>{let t=[];try{u(e,t,0)}catch(e){throw t.forEach(t=>{t.status=4,t.evaluationError=e}),e}},h=e=>{if(t[e]){if(t[e].evaluationError)throw t[e].evaluationError;return 4!==t[e].status&&(c(t[e]),f(t[e])),n.add(e),t[e].instance}},p={},v=e=>{let n=[e],s=new Set(n);for(;n.length>0;){let r=n.pop();if(!(r in t))return r in p||(p[r]=new Set),p[r].add(e),!1;void 0===t[r].instance&&t[r].dependencies.forEach(e=>{s.has(e)||(n.push(e),s.add(e))})}return!0},x=e=>{requestIdleCallback(()=>{try{v(e)&&(c(t[e]),requestIdleCallback(()=>{try{f(t[e])}catch(e){console.error(e)}}))}catch(e){console.error(e)}})},I=e=>{let n=e[0];(!t[n]||4!==t[n].status)&&(t[n]={id:n,initialize:e[1],dependencies:e[2],execute:void 0,instance:void 0,dependents:[],status:0,dfsIndex:void 0,dfsAncestorIndex:void 0,evaluationError:void 0},x(n),n in p&&(p[n].forEach(x),delete p[n]))},w=class{require(e){if(v(e))return h(e)}async import(e){return t[e]?.status===4?t[e]?.instance:o(e)}getImportedModules(){return new Set([...n])}constructor(d){e(this,"installResolver",e=>{let t={};o=n=>(n in t||(t[n]=e(n)),t[n]),Object.entries(i).forEach(([e,{resolve:t,reject:n}])=>{o(e).then(t,n),delete i[e]})}),e(this,"clean",()=>{Object.values(t).forEach(e=>{e.instance=void 0,e.status=0,e.evaluationError=void 0,e.execute=void 0,e.dependents=[],e.dfsIndex=void 0,e.dfsAncestorIndex=void 0,delete s[e.id]}),n=new Set}),e(this,"push",(...e)=>{for(let t=0;t<e.length;t++)try{I(e[t])}catch(n){console.error("Exception executing Module",e[t][0],n)}}),e(this,"yieldImport",e=>{let t=o,n=null;o=e=>(n=e,new Promise(()=>{}));try{return e(),n}catch(e){console.error("Could not yield import",e)}finally{o=t}return null}),e(this,"getChunkPromise",e=>r(e)),e(this,"getChunkEmptyPromise",e=>this.getChunkPromise(e)),e(this,"ensure",this.import),e(this,"installReloader",()=>{}),this.push(...d)}};globalThis.$WP=new w(globalThis.$WP||[])}"undefined"==typeof window||window.globalThis||(window.globalThis=window),!0===globalThis.__POLYFILLS_COMPLETE__?t():globalThis.__POLYFILLS_CALLBACK__=t}();
